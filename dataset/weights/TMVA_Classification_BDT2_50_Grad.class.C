// Class: ReadBDT2_50_Grad
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT2_50_Grad
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.24/00       [399360]
Creator        : root
Date           : Sun Jul 18 20:03:43 2021
Host           : Linux 3bfcc9c0a42a 4.15.0-1111-azure #123~16.04.1-Ubuntu SMP Sat Mar 20 01:52:07 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /root
Training events: 137141
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
NTrees: "50" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "2.5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
BoostType: "Grad" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
SeparationType: "sdivsqrtsplusb" [Separation criterion for node splitting]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
H: "False" [Print method-specific help message]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for BoostType=Grad algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "3" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "pray" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 7
max_eta                       max_eta                       max_eta                       max_eta                                                         'F'    [0.00606918334961,2.49267578125]
lep_eta1                      lep_eta1                      lep_eta1                      lep_eta1                                                        'F'    [-2.49169921875,2.49267578125]
inv_m                         inv_m                         inv_m                         inv_m                                                           'F'    [15.0092744827,1828.72692871]
dRHJ                          dRHJ                          dRHJ                          dRHJ                                                            'F'    [0.400012075901,4.19309711456]
dRLJ                          dRLJ                          dRLJ                          dRLJ                                                            'F'    [0.40001052618,4.0482134819]
dPhi0                         dPhi0                         dPhi0                         dPhi0                                                           'F'    [-3.14158391953,3.14149236679]
dPhi1                         dPhi1                         dPhi1                         dPhi1                                                           'F'    [-3.14158391953,3.14158391953]
NSpec 0


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#include <algorithm>
#include <limits>

#define NN new BDT2_50_GradNode

#ifndef BDT2_50_GradNode__def
#define BDT2_50_GradNode__def

class BDT2_50_GradNode {

public:

   // constructor of an essentially "empty" node floating in space
   BDT2_50_GradNode ( BDT2_50_GradNode* left,BDT2_50_GradNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDT2_50_GradNode();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDT2_50_GradNode* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDT2_50_GradNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDT2_50_GradNode*   fLeft;     // pointer to the left daughter node
   BDT2_50_GradNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 

//_______________________________________________________________________
   BDT2_50_GradNode::~BDT2_50_GradNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 

//_______________________________________________________________________
bool BDT2_50_GradNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] >= fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}

//_______________________________________________________________________
bool BDT2_50_GradNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}

#endif

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT2_50_Grad : public IClassifierReader {

 public:

   // constructor
   ReadBDT2_50_Grad( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "ReadBDT2_50_Grad" ),
        fNvars( 7 )
   {
      // the training input variables
      const char* inputVars[] = { "max_eta", "lep_eta1", "inv_m", "dRHJ", "dRLJ", "dPhi0", "dPhi1" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT2_50_Grad() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   double fVmin[7];
   double fVmax[7];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[7];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDT2_50_GradNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT2_50_Grad::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDT2_50_GradNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDT2_50_GradNode*)current->GetRight();
         else current=(BDT2_50_GradNode*)current->GetLeft();
      }
      myMVA += current->GetResponse();
   }
   return 2.0/(1.0+exp(-2.0*myMVA))-1.0;
}

void ReadBDT2_50_Grad::Initialize()
{
  double inf = std::numeric_limits<double>::infinity();
  double nan = std::numeric_limits<double>::quiet_NaN();
  // itree = 0
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.584245,0.16849) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.500946,0.00189157) , 
2, 121.938, 1, 0, 0.562456,0.0624557) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.480775,-0.0384491) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.375067,-0.249865) , 
3, 1.97396, 1, 0, 0.439618,-0.0603824) , 
3, 1.62423, 1, 0, 0.542248,0.0422475) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.408643,-0.182713) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.291783,-0.416435) , 
3, 1.1225, 1, 0, 0.359458,-0.140542) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.274083,-0.451834) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.131759,-0.736482) , 
3, 1.10458, 1, 0, 0.213,-0.287) , 
2, 265.888, 1, 0, 0.297558,-0.202442) , 
2, 187.744, 1, 0, 0.5,3.21229e-17)    );
  // itree = 1
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.572047,0.131714) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.532093,0.0302237) , 
4, 0.747449, 1, 0, 0.545553,0.0308807) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.449283,-0.057165) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.361833,-0.20557) , 
0, 2.18872, 1, 0, 0.425885,-0.0450812) , 
0, 1.78322, 1, 0, 0.52074,0.0151303) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.478269,-0.0544123) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.391813,-0.196225) , 
5, -1.68846, 1, 0, 0.414842,-0.0752154) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.510699,0.0134862) , 
5, 1.94461, 1, 0, 0.432842,-0.0598819) , 
4, 1.44235, 1, 0, 0.5,-0.00256933)    );
  // itree = 2
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.605121,0.163549) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.523742,0.00839219) , 
5, -2.37233, 1, 0, 0.537421,0.0164535) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.62484,0.193773) , 
5, 2.24379, 1, 0, 0.552195,0.0293432) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.483237,-0.0520417) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.553893,0.127053) , 
5, -0.449088, 1, 0, 0.530263,0.031313) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.462472,-0.0585163) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.5114,0.0349417) , 
6, 1.85933, 1, 0, 0.473659,-0.0173771) , 
6, -2.24399, 1, 0, 0.481549,-0.0105902) , 
3, 0.761258, 1, 0, 0.5,-0.000160355)    );
  // itree = 3
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.463054,-0.0377869) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.534701,0.0270566) , 
1, -1.14673, 1, 0, 0.52005,0.00653816) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.46083,-0.0335726) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.346895,-0.140371) , 
0, 2.13107, 1, 0, 0.432508,-0.0276793) , 
1, 1.54327, 1, 0, 0.510837,0.00293704) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.149188,-0.256504) , 
2, 360.479, 1, 0, 0.5,0.000156661)    );
  // itree = 4
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.536227,0.059696) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.451762,-0.0689521) , 
5, -2.22976, 1, 0, 0.4685,-0.0200904) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.544505,0.0926657) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.465713,-0.0755798) , 
5, 0.0497174, 1, 0, 0.521649,0.0202268) , 
6, 1.04719, 1, 0, 0.487213,-0.00589553) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.572442,-0.0296307) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.575091,0.153734) , 
6, -2.1152, 1, 0, 0.574584,0.0546511) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.572208,-0.0284439) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.403102,-0.213578) , 
2, 65.9876, 1, 0, 0.473164,-0.0631867) , 
6, 0.449034, 1, 0, 0.543334,0.0183421) , 
5, 1.64552, 1, 0, 0.5,-0.000373083)    );
  // itree = 5
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.567801,0.13618) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.532645,0.0574925) , 
6, -2.88513, 1, 0, 0.548531,0.0429549) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.428345,-0.103428) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.515541,0.0130237) , 
6, -0.106732, 1, 0, 0.484666,-0.0130137) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.56605,0.114212) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.47935,-0.0341968) , 
6, -0.918811, 1, 0, 0.509324,0.00771405) , 
5, 0.448745, 1, 0, 0.495007,-0.00432102) , 
6, -2.54319, 1, 0, 0.5,8.90685e-05)    );
  // itree = 6
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.592984,0.0435141) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.458676,0.145126) , 
3, 1.60632, 1, 0, 0.570036,0.0281609) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.623845,0.0317097) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.517946,-0.0466524) , 
4, 0.868263, 1, 0, 0.556408,-0.00863883) , 
2, 76.6995, 1, 0, 0.565264,0.0152742) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.555204,0.0476973) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.461682,-0.0612486) , 
3, 0.549374, 1, 0, 0.470769,-0.0231288) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.443529,0.1054) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.356504,-0.0278043) , 
4, 0.747546, 1, 0, 0.376335,0.00131688) , 
0, 1.66316, 1, 0, 0.437578,-0.014537) , 
2, 101.377, 1, 0, 0.5,3.6849e-05)    );
  // itree = 7
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.538616,0.0272827) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.507295,-0.0333879) , 
5, -1.3463, 1, 0, 0.515828,-0.00766196) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.57507,-0.0384132) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.558102,0.11232) , 
5, -0.448033, 1, 0, 0.565173,0.0231043) , 
6, 2.54319, 1, 0, 0.52074,-0.00459935) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.422186,0.100151) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.408194,0.00935211) , 
6, -0.149375, 1, 0, 0.414842,0.0229601) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.510699,-0.0482008) , 
5, 1.94461, 1, 0, 0.432842,0.0145865) , 
4, 1.44235, 1, 0, 0.5,-7.23092e-05)    );
  // itree = 8
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.542538,-0.0360241) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.507506,0.00485025) , 
5, -2.24386, 1, 0, 0.512296,-0.000305934) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.49276,0.11955) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.456041,0.0247506) , 
4, 1.73664, 1, 0, 0.467232,0.024267) , 
4, 1.66571, 1, 0, 0.508344,0.00184889) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.361121,-0.126821) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.376048,-0.0170414) , 
6, -0.148841, 1, 0, 0.369223,-0.0295118) , 
4, 1.96353, 1, 0, 0.5,-3.21101e-05)    );
  // itree = 9
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.487671,-0.174101) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.553902,0.0537072) , 
5, -1.64581, 1, 0, 0.544925,0.0102022) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.53538,0.020561) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.488491,-0.0316915) , 
5, -0.747891, 1, 0, 0.50695,-0.00508518) , 
6, -1.64559, 1, 0, 0.515544,-0.0016254) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.392058,-0.040358) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.412898,0.0655414) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.356728,-0.0216057) , 
4, 1.60635, 1, 0, 0.398437,0.0185847) , 
6, -1.64561, 1, 0, 0.397012,0.0105046) , 
0, 2.01904, 1, 0, 0.5,-3.46977e-05)    );
  // itree = 10
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.493419,-0.0294962) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.545139,0.081561) , 
5, -0.919355, 1, 0, 0.526236,0.0184727) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.519949,0.00393938) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.432895,-0.0435652) , 
5, -0.919007, 1, 0, 0.481093,-0.00784469) , 
6, -2.24399, 1, 0, 0.487398,-0.00416861) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.57034,-0.0706553) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.562556,0.0428193) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.311159,-0.0368976) , 
2, 175.479, 1, 0, 0.51414,0.0133114) , 
6, -2.24398, 1, 0, 0.521776,0.00728328) , 
5, 0.747939, 1, 0, 0.5,2.92681e-05)    );
  // itree = 11
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.546219,-0.00981449) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.550177,-0.0485515) , 
6, 1.04732, 1, 0, 0.547468,-0.0100705) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.546926,0.0607766) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.480723,-0.0121001) , 
4, 0.63168, 1, 0, 0.499936,0.00401312) , 
3, 1.10482, 1, 0, 0.526633,-0.0038971) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.573965,0.0728802) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.429878,-0.0210473) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.472283,0.0153054) , 
1, -0.59289, 1, 0, 0.458004,0.00142216) , 
3, 0.580635, 1, 0, 0.469384,0.0045313) , 
4, 1.09491, 1, 0, 0.5,2.38923e-05)    );
  // itree = 12
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.51809,0.0255231) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.424056,-0.0680711) , 
5, -2.14432, 1, 0, 0.457725,-0.0157752) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.528904,0.0191789) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.46196,-0.0884812) , 
6, 0.106797, 1, 0, 0.52311,0.00435059) , 
5, -0.149707, 1, 0, 0.496724,-0.00377117) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.556161,-0.0430383) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.548781,0.0702599) , 
5, -2.24382, 1, 0, 0.550899,0.0173632) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.438642,-0.0348954) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.550201,0.079923) , 
6, 2.75691, 1, 0, 0.458095,-0.006829) , 
5, -0.448708, 1, 0, 0.504519,0.00527276) , 
6, 0.448798, 1, 0, 0.5,2.97526e-05)    );
  // itree = 13
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.563174,0.0485103) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.561276,-0.0108603) , 
2, 60.2488, 1, 0, 0.562029,0.00601614) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.429054,-0.0157717) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.508674,0.0662451) , 
5, 2.543, 1, 0, 0.437285,-0.00325023) , 
2, 101.377, 1, 0, 0.498266,0.00127965) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.536355,-0.0595727) , 
6, 2.84239, 1, 0, 0.5,8.36152e-06)    );
  // itree = 14
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.479744,0.0128872) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.572502,0.122019) , 
5, 0.705081, 1, 0, 0.498651,0.0159216) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.552254,0.03161) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.466905,-0.0128002) , 
5, -2.28659, 1, 0, 0.484239,-0.00170132) , 
6, -1.34639, 1, 0, 0.488106,0.00302656) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.580581,-0.00136798) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.572442,-0.200872) , 
5, 2.11553, 1, 0, 0.576499,-0.0419768) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.527698,0.0258397) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.481545,-0.0993406) , 
6, 1.77391, 1, 0, 0.519692,0.00160261) , 
6, -1.64526, 1, 0, 0.532417,-0.00815895) , 
5, 1.34633, 1, 0, 0.5,2.40457e-05)    );
  // itree = 15
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.575633,0.0557209) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.541344,-0.0422744) , 
6, -2.11557, 1, 0, 0.547459,-0.0110242) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.525545,-0.0379597) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.465337,0.0107334) , 
0, 0.71903, 1, 0, 0.475834,0.000888351) , 
3, 0.76131, 1, 0, 0.494547,-0.00222399) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.532431,-0.171458) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.546879,0.123176) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.503709,0.0101871) , 
5, 1.00442, 1, 0, 0.534403,0.0410408) , 
5, -1.346, 1, 0, 0.533966,0.0150175) , 
6, 2.24399, 1, 0, 0.5,0.000161074)    );
  // itree = 16
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.583841,0.0125103) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.402902,0.0927847) , 
3, 1.95079, 1, 0, 0.572162,0.00805809) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.442899,-0.0803091) , 
1, 1.78188, 1, 0, 0.565264,0.00561357) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.541138,-0.00639979) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.290628,-0.144088) , 
2, 177.502, 1, 0, 0.449223,-0.0236072) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.416866,-0.0130651) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.490193,0.0292084) , 
5, 1.64547, 1, 0, 0.435058,-0.00115422) , 
6, -1.94481, 1, 0, 0.437578,-0.0051491) , 
2, 101.377, 1, 0, 0.5,0.000112459)    );
  // itree = 17
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.562046,0.0191262) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.397328,-0.104774) , 
2, 67.4818, 1, 0, 0.471387,-0.021658) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.540945,0.103968) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.556354,-0.00694905) , 
6, 1.09025, 1, 0, 0.548365,0.0230056) , 
6, -0.448798, 1, 0, 0.523805,0.0087556) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.617421,0.0753356) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.509529,-0.00126206) , 
0, 0.825293, 1, 0, 0.536509,0.00798813) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.457624,-0.0331815) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.5067,0.0122208) , 
6, 1.31793, 1, 0, 0.475969,-0.00717306) , 
6, -1.64559, 1, 0, 0.491367,-0.00331701) , 
5, -1.34642, 1, 0, 0.5,-0.000103931)    );
  // itree = 18
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.568648,-0.00637811) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.641368,0.0385213) , 
5, 1.94476, 1, 0, 0.582094,0.000780093) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.43786,-0.0347483) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.305806,-0.136967) , 
3, 0.948605, 1, 0, 0.377135,-0.0348641) , 
2, 160.412, 1, 0, 0.547248,-0.00527984) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.529316,-0.0111895) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.308539,0.0551913) , 
2, 187.775, 1, 0, 0.482304,0.00029808) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.47474,0.178795) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.335011,-0.00140721) , 
0, 1.49816, 1, 0, 0.374441,0.0215422) , 
3, 1.66441, 1, 0, 0.462421,0.00421416) , 
0, 1.19017, 1, 0, 0.5,8.25492e-06)    );
  // itree = 19
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.48489,0.000921106) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.516437,-0.0574391) , 
5, 1.94461, 1, 0, 0.490665,-0.00434345) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.566243,-0.0155636) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.517635,0.0199815) , 
4, 0.744634, 1, 0, 0.530243,0.0049258) , 
1, -0.59289, 1, 0, 0.517497,0.00194049) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.402795,-0.0626782) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.437622,0.138681) , 
2, 101.667, 1, 0, 0.415724,0.00461971) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.171343,-0.219212) , 
2, 155.012, 1, 0, 0.340165,-0.0191826) , 
3, 1.845, 1, 0, 0.5,-0.00014363)    );
  // itree = 20
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.632394,0.0777993) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.570097,-0.0321071) , 
3, 0.504556, 1, 0, 0.6028,0.0113267) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.528602,0.00207244) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.509909,-0.0168387) , 
6, -0.448798, 1, 0, 0.517822,-0.00403082) , 
3, 0.568894, 1, 0, 0.526549,-0.00245367) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.526032,0.0726155) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.446937,-0.00143811) , 
0, 2.12054, 1, 0, 0.497674,0.0216617) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.371947,0.0302068) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.346573,-0.0466365) , 
5, 0.149792, 1, 0, 0.360244,-0.00206862) , 
2, 101.41, 1, 0, 0.412807,0.0070075) , 
0, 1.78222, 1, 0, 0.5,-0.000245303)    );
  // itree = 21
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.594734,0.0493553) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.570526,-0.0145031) , 
5, -2.75691, 1, 0, 0.581388,0.00634852) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.452789,-0.0884882) , 
0, 1.54869, 1, 0, 0.53666,-0.00970161) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.465925,-0.0086909) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.53799,0.0252456) , 
6, 1.94479, 1, 0, 0.481199,-0.000633457) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.589035,-0.0401369) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.534654,0.0545531) , 
6, -1.04676, 1, 0, 0.55163,0.0112406) , 
5, 2.1157, 1, 0, 0.494174,0.00155405) , 
5, -2.244, 1, 0, 0.5,1.06047e-05)    );
  // itree = 22
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.56449,0.000316827) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.459228,-0.0712627) , 
4, 1.40477, 1, 0, 0.543362,-0.00628898) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.473326,0.00457635) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.470072,0.0279361) , 
6, 0.00701269, 1, 0, 0.472052,0.00609011) , 
0, 0.953348, 1, 0, 0.493736,0.00232592) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.626432,0.0473058) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.558237,-0.0261109) , 
5, -0.148501, 1, 0, 0.595349,0.00599761) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.549143,0.0221155) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.467224,-0.0665985) , 
3, 0.750581, 1, 0, 0.486987,-0.0201655) , 
0, 1.06102, 1, 0, 0.527988,-0.0102663) , 
6, 1.94479, 1, 0, 0.5,2.29937e-05)    );
  // itree = 23
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.635105,0.000594498) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.427391,-0.103132) , 
2, 153.399, 1, 0, 0.575085,-0.0131977) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.548105,-0.0062656) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.299574,0.0297412) , 
2, 187.744, 1, 0, 0.506138,-0.000537833) , 
3, 0.580635, 1, 0, 0.513724,-0.00193074) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.348837,-0.0494678) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.476513,0.0857187) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.423915,0.00970607) , 
6, -0.747732, 1, 0, 0.442928,0.0160383) , 
1, -1.54713, 1, 0, 0.427835,0.0101773) , 
4, 1.61608, 1, 0, 0.5,3.98486e-06)    );
  // itree = 24
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.527192,0.014129) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.214167,-0.0718276) , 
2, 247.475, 1, 0, 0.501398,0.00398532) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.523803,-0.0399742) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.518297,-0.00625809) , 
1, -0.0726783, 1, 0, 0.518952,-0.00461513) , 
1, -0.305315, 1, 0, 0.511861,-0.00114101) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.448258,0.121969) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.309733,0.00928932) , 
3, 1.11848, 1, 0, 0.377067,0.0276105) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.357403,-0.0343168) , 
6, 0.747926, 1, 0, 0.369816,0.0120998) , 
0, 2.13745, 1, 0, 0.5,-3.53788e-05)    );
  // itree = 25
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.581296,0.04573) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.559361,0.0216921) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.486356,-0.002968) , 
4, 0.573734, 1, 0, 0.49427,-0.000133945) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.52977,-0.0485155) , 
5, 2.8423, 1, 0, 0.495887,-0.00109153) , 
0, 0.361299, 1, 0, 0.5,-4.41024e-05)    );
  // itree = 26
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.572137,0.0235825) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.553619,-0.065246) , 
1, -0.436733, 1, 0, 0.562082,-0.0108304) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.53483,0.0239889) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.492979,-0.000377305) , 
5, -1.34642, 1, 0, 0.504323,0.0028248) , 
4, 0.573752, 1, 0, 0.510704,0.00131621) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.522764,0.017185) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.44601,-0.0465844) , 
4, 0.916945, 1, 0, 0.473814,-0.0104972) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.356403,0.081839) , 
3, 1.77869, 1, 0, 0.458435,-0.00505095) , 
1, 1.06857, 1, 0, 0.5,1.23317e-05)    );
  // itree = 27
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.48518,-0.0669923) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.422806,0.011617) , 
0, 1.31024, 1, 0, 0.453451,-0.0125632) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.594134,0.0392078) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.486744,-0.0200579) , 
0, 1.18308, 1, 0, 0.535908,0.00308496) , 
6, 0.149599, 1, 0, 0.49969,-0.00378835) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.580019,0.0415033) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.482446,-0.00311285) , 
0, 1.30807, 1, 0, 0.533579,0.00888841) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.488985,-0.0673973) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.447546,0.0167225) , 
0, 0.947782, 1, 0, 0.459258,-0.00345872) , 
6, -0.149592, 1, 0, 0.500276,0.00335557) , 
5, -0.149643, 1, 0, 0.5,-4.26053e-06)    );
  // itree = 28
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.599258,0.0465106) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.508441,-0.0146035) , 
2, 76.1061, 1, 0, 0.542085,0.00376192) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.436555,-0.0129042) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.434941,-0.0714545) , 
1, -0.909526, 1, 0, 0.436179,-0.0116919) , 
0, 1.36197, 1, 0, 0.492828,-0.00342568) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.561448,0.00182119) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.364427,-0.110507) , 
3, 1.72137, 1, 0, 0.541753,-0.00399409) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.445933,0.0102178) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.535526,0.0670326) , 
5, 1.64546, 1, 0, 0.467623,0.0106118) , 
0, 1.30858, 1, 0, 0.506178,0.00301532) , 
1, -0.118187, 1, 0, 0.5,3.46896e-05)    );
  // itree = 29
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.518734,-0.00183132) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.411609,0.0296114) , 
0, 2.01825, 1, 0, 0.506906,0.000659351) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.594631,0.0699277) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.474213,-0.019717) , 
3, 1.09965, 1, 0, 0.541624,0.0138725) , 
1, 0.729306, 1, 0, 0.510704,0.00210462) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.482999,0.00221092) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.338992,-0.0589694) , 
1, 1.95017, 1, 0, 0.451345,-0.00463778) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.504017,-0.0711647) , 
5, 2.24368, 1, 0, 0.458435,-0.00821699) , 
1, 1.06857, 1, 0, 0.5,-9.05431e-06)    );
  // itree = 30
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.384949,-0.0407088) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.444327,0.0474817) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.517824,-0.00243992) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.401173,0.0257427) , 
0, 2.01904, 1, 0, 0.506423,7.42845e-05) , 
1, -1.80187, 1, 0, 0.504574,0.000688038) , 
1, -2.017, 1, 0, 0.5,2.04874e-06)    );
  // itree = 31
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.572105,0.00357983) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.631533,0.0633444) , 
6, 1.34646, 1, 0, 0.589427,0.00933854) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.514668,-0.00276046) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.444171,-0.0659059) , 
3, 1.54396, 1, 0, 0.510689,-0.00280636) , 
0, 0.598118, 1, 0, 0.521718,-0.00110524) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.392269,0.0761659) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.366874,-0.0718377) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.380726,0.0170821) , 
1, -0.0528041, 1, 0, 0.376778,-0.0035644) , 
1, -0.836751, 1, 0, 0.381121,0.00598471) , 
3, 1.66437, 1, 0, 0.5,-1.00458e-05)    );
  // itree = 32
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.498589,-0.031543) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.550859,-0.00109443) , 
1, -0.809082, 1, 0, 0.537726,-0.00395464) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.475253,0.0368265) , 
4, 1.7898, 1, 0, 0.53258,-0.00230058) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.533354,-0.00989265) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.420813,0.0310703) , 
2, 95.2442, 1, 0, 0.473974,0.00472777) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.262529,-0.0732214) , 
3, 2.29225, 1, 0, 0.460492,0.00274341) , 
3, 1.1225, 1, 0, 0.5,-2.09915e-05)    );
  // itree = 33
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.503706,-0.00475479) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.564112,0.0535288) , 
2, 27.5429, 1, 0, 0.550098,0.0186125) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.593276,-0.0148381) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.539056,0.00984588) , 
0, 1.31024, 1, 0, 0.5697,-0.00171462) , 
2, 47.9108, 1, 0, 0.565264,0.00288603) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.454069,0.00953505) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.427196,-0.0161567) , 
6, -1.34643, 1, 0, 0.434623,-0.00392039) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.495036,0.0434932) , 
5, 2.84218, 1, 0, 0.437578,-0.00281498) , 
2, 101.377, 1, 0, 0.5,-2.7924e-05)    );
  // itree = 34
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.519962,0.0117915) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.319654,-0.0517013) , 
2, 224.755, 1, 0, 0.509667,0.00401594) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.183108,-0.0574813) , 
2, 274.112, 1, 0, 0.487398,0.0025823) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.568351,-0.0672619) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.46748,0.0337451) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.525138,-0.0109151) , 
1, -1.52237, 1, 0, 0.517805,-0.0023284) , 
0, 0.473942, 1, 0, 0.521776,-0.00443522) , 
5, 0.747939, 1, 0, 0.5,9.91422e-06)    );
  // itree = 35
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.506309,-0.0264243) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.567658,0.0176497) , 
1, -0.993647, 1, 0, 0.54655,0.0010229) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.615769,0.0372003) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.526653,-0.023979) , 
6, -2.5428, 1, 0, 0.535494,-0.00822071) , 
1, 0.360282, 1, 0, 0.542248,-0.00257452) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.222771,-0.0248932) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.352566,0.17807) , 
1, -1.46859, 1, 0, 0.285807,0.0278358) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.308049,-0.0203552) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.291731,0.0971791) , 
4, 1.26166, 1, 0, 0.302822,0.00522519) , 
1, -0.838704, 1, 0, 0.297558,0.0122211) , 
2, 187.744, 1, 0, 0.5,-1.99535e-05)    );
  // itree = 36
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.580976,-0.0465688) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.491895,-0.00223097) , 
0, 1.54761, 1, 0, 0.548531,-0.0131495) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.4177,0.0686335) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.41864,-0.0210463) , 
5, 0.448886, 1, 0, 0.418088,0.013375) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.522466,0.00501118) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.403964,-0.0198075) , 
0, 1.76582, 1, 0, 0.500848,0.000284244) , 
1, -1.78327, 1, 0, 0.495007,0.00120811) , 
6, -2.54319, 1, 0, 0.5,-0.000131223)    );
  // itree = 37
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.530366,-0.0140242) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.572723,0.0684916) , 
6, 1.04719, 1, 0, 0.544144,0.00578967) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.524411,-0.00550861) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.277209,-0.0687059) , 
2, 160.112, 1, 0, 0.466436,-0.00793463) , 
3, 0.761258, 1, 0, 0.486701,-0.00435557) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.531874,0.00841679) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.394017,-0.0577875) , 
3, 1.70853, 1, 0, 0.521246,0.00155034) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.320776,0.0583009) , 
3, 2.01658, 1, 0, 0.50863,0.00282002) , 
1, -0.355539, 1, 0, 0.5,-3.92482e-06)    );
  // itree = 38
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.507041,-0.00568609) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.420343,-0.0724705) , 
5, -0.00718387, 1, 0, 0.502523,-0.00405484) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.446934,0.0436035) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.525094,0.00102487) , 
1, -1.4745, 1, 0, 0.514818,0.00284398) , 
5, 0.149551, 1, 0, 0.50835,-0.000785367) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.43037,0.0851484) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.356262,-0.0214738) , 
4, 1.08932, 1, 0, 0.387193,0.00986995) , 
1, 1.78062, 1, 0, 0.5,-5.10102e-05)    );
  // itree = 39
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.379672,-0.0894036) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.426971,0.0063958) , 
6, -0.748074, 1, 0, 0.409948,-0.0118283) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.558857,-0.0387598) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.555951,0.0106435) , 
4, 0.916961, 1, 0, 0.557185,-0.0045245) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.497569,0.00408995) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.38252,0.0349363) , 
4, 1.89694, 1, 0, 0.488891,0.00277918) , 
3, 0.761258, 1, 0, 0.506774,0.000866675) , 
1, -1.77965, 1, 0, 0.5,-2.1449e-05)    );
  // itree = 40
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.530981,0.0259144) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.467366,-0.0337055) , 
4, 1.3265, 1, 0, 0.517049,0.00564663) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.5508,-0.0288436) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.491572,0.00378294) , 
0, 0.827182, 1, 0, 0.506184,-0.00187588) , 
6, -0.448798, 1, 0, 0.51078,0.0013061) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.379346,-0.0131971) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.403131,-0.125873) , 
5, 0.44811, 1, 0, 0.388926,-0.024941) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.439273,0.0449073) , 
6, 1.04741, 1, 0, 0.403997,-0.011687) , 
4, 1.7898, 1, 0, 0.5,-5.57329e-06)    );
  // itree = 41
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.579627,-0.0379616) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.551422,0.00987406) , 
5, -1.94455, 1, 0, 0.556403,0.000676348) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.564008,0.0541163) , 
1, 0.516805, 1, 0, 0.557808,0.00498335) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.563311,0.0343706) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.500181,-0.0161486) , 
3, 0.5766, 1, 0, 0.506701,-0.00486717) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.454797,0.0166544) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.454782,-0.017657) , 
6, 0.747996, 1, 0, 0.454792,0.00185812) , 
4, 1.09491, 1, 0, 0.481516,-0.00160423) , 
0, 0.834938, 1, 0, 0.5,-8.20439e-06)    );
  // itree = 42
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.53762,-0.014064) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.242281,0.0607864) , 
2, 274.122, 1, 0, 0.518006,-0.00465812) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.401637,-0.0121253) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.368833,0.0603358) , 
6, -1.2609, 1, 0, 0.384568,0.0101083) , 
3, 1.65729, 1, 0, 0.496724,-0.00230305) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.518902,0.0113651) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.446586,-0.033719) , 
5, 0.91895, 1, 0, 0.505136,0.00119764) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.49681,0.0630132) , 
5, 2.54313, 1, 0, 0.504519,0.00320289) , 
6, 0.448798, 1, 0, 0.5,1.09468e-05)    );
  // itree = 43
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.545132,-0.0275357) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.59137,0.0599368) , 
4, 0.474447, 1, 0, 0.575883,0.013581) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.515961,0.00590885) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.501343,-0.0122166) , 
1, 0.356515, 1, 0, 0.510194,-0.000558391) , 
4, 0.573734, 1, 0, 0.517497,0.00101344) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.372495,0.0173215) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.34883,-0.0796237) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.285869,-0.0125676) , 
3, 2.18048, 1, 0, 0.32036,-0.0198352) , 
0, 1.30778, 1, 0, 0.340165,-0.00959786) , 
3, 1.845, 1, 0, 0.5,-3.35264e-05)    );
  // itree = 44
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.547885,-0.00049926) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.415321,0.0288704) , 
2, 167.754, 1, 0, 0.530983,0.00141692) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.308319,-0.0957177) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.255743,0.0399691) , 
2, 266.461, 1, 0, 0.27958,-0.0106161) , 
2, 228.857, 1, 0, 0.510837,0.000452647) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.149188,-0.0569256) , 
2, 360.479, 1, 0, 0.5,-1.42777e-07)    );
  // itree = 45
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.492267,-0.0471562) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.512606,0.0160817) , 
5, -2.28675, 1, 0, 0.510576,0.00419715) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.513249,0.000224321) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.177246,-0.09171) , 
2, 274.112, 1, 0, 0.490811,-0.00171587) , 
6, -0.747996, 1, 0, 0.498178,0.000488049) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.537874,-0.0264126) , 
5, 2.8423, 1, 0, 0.5,-6.65651e-05)    );
  // itree = 46
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.572186,-0.00477809) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.459861,0.0244845) , 
3, 1.60621, 1, 0, 0.552812,0.000117981) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.444613,-0.0598872) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.467077,0.0267578) , 
1, 0.824219, 1, 0, 0.451153,-0.0158462) , 
2, 154.839, 1, 0, 0.542248,-0.00154104) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.363567,0.0799988) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.328384,-0.0269499) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.196757,0.0295397) , 
3, 1.1225, 1, 0, 0.271546,-0.00265137) , 
4, 0.747572, 1, 0, 0.297558,0.00712129) , 
2, 187.744, 1, 0, 0.5,-4.54242e-05)    );
  // itree = 47
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.569411,-0.00384492) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.4931,0.0144845) , 
0, 1.19017, 1, 0, 0.528653,0.00267789) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.521821,0.0157114) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.431056,-0.0284054) , 
0, 1.18614, 1, 0, 0.469181,-0.00421953) , 
3, 1.32891, 1, 0, 0.512525,0.000807437) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.321568,-0.0562211) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.292197,-0.00259481) , 
4, 1.37749, 1, 0, 0.309225,-0.0131297) , 
3, 2.02562, 1, 0, 0.5,-5.12096e-05)    );
  // itree = 48
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.568446,-0.0113459) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.47645,-0.0853737) , 
6, -0.790793, 1, 0, 0.542561,-0.0143476) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.607144,0.0433018) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.50568,-0.0296404) , 
5, -0.44873, 1, 0, 0.560474,0.0039924) , 
6, 0.14961, 1, 0, 0.551248,-0.00545306) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.517121,-0.0131843) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.438135,0.0124768) , 
0, 1.19017, 1, 0, 0.471643,0.000628814) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.584655,0.0384318) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.43336,-0.0373869) , 
0, 1.76223, 1, 0, 0.54834,0.00900277) , 
5, 2.24391, 1, 0, 0.482641,0.0018296) , 
4, 0.747458, 1, 0, 0.5,-1.30637e-05)    );
  // itree = 49
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.525946,0.0683325) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.559247,-0.0376792) , 
6, 0.148969, 1, 0, 0.542652,0.00717992) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.475796,-0.0115888) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.572009,0.0357158) , 
5, 2.59997, 1, 0, 0.486264,-0.00286443) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.533118,0.0262697) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.480855,-0.0622865) , 
5, 1.78801, 1, 0, 0.526128,0.00629169) , 
6, 1.64559, 1, 0, 0.495619,-0.000715729) , 
5, -2.5432, 1, 0, 0.5,1.97817e-05)    );
   return;
};

// Clean up
inline void ReadBDT2_50_Grad::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}

inline double ReadBDT2_50_Grad::GetMvaValue( const std::vector<double>& inputValues ) const
{
   // classifier response value
   double retval = 0;

   // classifier response, sanity check first
   if (!IsStatusClean()) {
      std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                << " because status is dirty" << std::endl;
   }
   else {
         retval = GetMvaValue__( inputValues );
   }

   return retval;
}
